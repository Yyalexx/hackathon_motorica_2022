# Описание задачи 2 этапа

На первом этапе каждому наблюдению соответствовало одно значение целевой переменной, которое обозначало какой жест был выполнен внутри этого наблюдения.  
Главное отличие текущей задачи от предыдущей состоит в том, что теперь целевая переменная представляет из себя маску, в которой каждый элемент отражает, какая команда выполнялась пользователем. Индекс (позиция) элемента в маске отражает временной шаг соответствующий аналогичному временному шагу в наблюдении.

## Описание данных

[Данные](https://drive.google.com/drive/folders/1G1hprT8uJIs8ED0c_rFRSEnTWgAKc-Ip?usp=sharing) представляют из себя временные ряды, где в каждый момент времени фиксируются показания от датчиков.  
Целевая переменная представляет из себя маску команды выполняемого пользователем жеста в каждый момент времени.

*X_train.npy* - обучающая выборка;  
*y_train.csv* - маска выполнения жеста для обучающей выборки  
*X_test.npy* - тестовая выборка  
*sample_submission.csv* - некоторое решение задачи из которого можно взять формат

X_train.npy и X_test.npy имеют следующие размерности - (наблюдения, датчики, время)  
y_train.csv и y_test.csv имеют следующие размерности - (наблюдения * время) - это обусловленно форматом ответов для Kaggle

y_train.csv содержит следующие классы:

0 - команда "жест open";  
1 - команда "сгиб мизинца";  
2 - команда "сгиб безымянного пальца";  
3 - команда "сгиб среднего пальца";  
4 - команда "жест пистолет";  
5 - команда "сгиб указательного пальца";  
6 - команда "сгиб большога пальца";  
7 - команда "жест ОК";  
8 - команда "жест grab"  

## Описание проделанной работы
Первоначально была произведена обработка целевой переменной, переопределена координата смены класса с использованием функции diff, переразмечен y_train c использованием списка координат смены класса для наблюдений.

- Первый вариант решения задачи - с помощью нейронной сети Keras представлен в файле *add_3_fin.ipynb*.  
В качестве y_train мы взяли свою разметку, в которой переход класса определяется по максимальному изменению показаний одного из 16 датчиков.  
После обучения модели была сделана постобработка для сглаживания неоднозначности определения выполненной пользователем команды.  
Мы использовали сглаживание sbmission модой с окном 7. Данное значение было определено экспериментальным путём.

Тренировка модели проходит в несколько этапов:  
Обучение 25 эпох с learning_rate=1e-3.  
Дообучение модели 2 раза по 10 эпох с learning_rate=1e-4.
Кросс-валидация на нейронных сетях занимает около получаса времени.  
Данное решение имело score 0.98703, обученная модель представлена в файле *model_1.h5*.

- Второй вариант решения задачи - последовательно применим к нашим данным две модели машинного обучения, файл *2_logreg_mode-CV_2.ipynb*.  
Первая модель logistic regression, будет выполнять бинарную классификацию и определять был ли осуществлен жест или нет.  
Если жест был сделан, то мы применяем к таким жестам вторую модель многоклассовой классификации logistic regression, которая уже в свою очередь классифицирует жест по виду.

Score у данного решения - 0.97407.

Для обучения модели на новых данных был написан скрипт *predict_2.py*.  
На вход модели подается массив формата (N, 40, 100), где N количество жестов, на выходе имеем массив y формата (N, 100) и одномерный массив y_flat формата (N*100).  
Данный скрипт делает предсказание на основе модели из файла *model_1.h5*.

Также в [директории c данными](https://drive.google.com/drive/folders/1G1hprT8uJIs8ED0c_rFRSEnTWgAKc-Ip?usp=sharing) содержится два файла разметки y_train: *y_train_250_5_61_-2.csv* и *y_train_250_5_61_-3.csv* со сдвигами -2 и -3 соответственно.

## Выводы
Наибольший score был получен при решении с нейронной сетью - 0.98703.

Для распознавания команд, которые выполнялись пользователем, были применены модели машинного обучения, которые решали задачу классификации.

Основной задачей стало правильная разметка целевой переменной, что позволило качественно обучить модели. Также наилучшей метрики позволила достичь постобработка submission с помощью mode.

Данные модели обеспечивают достаточно хорошую классификацию команд пользователей.